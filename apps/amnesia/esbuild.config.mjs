import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import esbuildSvelte from "esbuild-svelte";
import sveltePreprocess from "svelte-preprocess";
import fs from "fs";
import path from "path";
import { execSync } from "child_process";

const banner = `/*
Amnesia -

Generated by esbuild
*/
`;

const prod = process.argv[2] === "production";
const skipServer = process.argv.includes("--skip-server");

// Output directory for the plugin
const pluginDir = "temp/vault/.obsidian/plugins/amnesia";

// Ensure output directory exists
if (!fs.existsSync(pluginDir)) {
  fs.mkdirSync(pluginDir, { recursive: true });
}

// Copy WASM file to plugin output directory
const wasmSource = "src/wasm/epub-processor/pkg/epub_processor_bg.wasm";
const wasmDest = path.join(pluginDir, "epub_processor_bg.wasm");

if (fs.existsSync(wasmSource)) {
  fs.copyFileSync(wasmSource, wasmDest);
  console.log(`Copied WASM: ${wasmSource} -> ${wasmDest}`);
}

// =============================================================================
// SERVER BINARY BUNDLING
// =============================================================================

/**
 * Build and bundle the amnesia-server binary
 */
function bundleServerBinary() {
  const serverDir = path.resolve("../amnesia-server");
  const platform = process.platform;
  const binaryName = platform === "win32" ? "amnesia-server.exe" : "amnesia-server";

  // Server output directory within plugin
  const serverOutDir = path.join(pluginDir, "server");
  if (!fs.existsSync(serverOutDir)) {
    fs.mkdirSync(serverOutDir, { recursive: true });
  }

  // Check if server directory exists
  if (!fs.existsSync(serverDir)) {
    console.warn(`âš ï¸  Server directory not found: ${serverDir}`);
    console.warn("   Skipping server build. Server will need to be installed manually.");
    return false;
  }

  // Check if Cargo is available
  try {
    execSync("cargo --version", { stdio: "ignore" });
  } catch {
    console.warn("âš ï¸  Cargo not found. Skipping server build.");
    console.warn("   Install Rust from https://rustup.rs to enable server bundling.");
    return false;
  }

  console.log("\nðŸ“¦ Building amnesia-server...");

  try {
    // Build the server in release mode
    execSync("cargo build --release", {
      cwd: serverDir,
      stdio: "inherit",
    });

    // Find the built binary
    const binarySource = path.join(serverDir, "target", "release", binaryName);
    const binaryDest = path.join(serverOutDir, binaryName);

    if (fs.existsSync(binarySource)) {
      fs.copyFileSync(binarySource, binaryDest);

      // Make binary executable on Unix
      if (platform !== "win32") {
        fs.chmodSync(binaryDest, 0o755);
      }

      const stats = fs.statSync(binaryDest);
      const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);
      console.log(`âœ… Server binary bundled: ${binaryDest} (${sizeMB} MB)`);
      return true;
    } else {
      console.error(`âŒ Binary not found at: ${binarySource}`);
      return false;
    }
  } catch (error) {
    console.error("âŒ Server build failed:", error.message);
    return false;
  }
}

// Build server binary for production builds (unless skipped)
if (prod && !skipServer) {
  bundleServerBinary();
} else if (!skipServer) {
  // In dev mode, just copy existing binary if available
  const serverDir = path.resolve("../amnesia-server");
  const platform = process.platform;
  const binaryName = platform === "win32" ? "amnesia-server.exe" : "amnesia-server";

  // Try release first, then debug
  const releaseBinary = path.join(serverDir, "target", "release", binaryName);
  const debugBinary = path.join(serverDir, "target", "debug", binaryName);
  const serverOutDir = path.join(pluginDir, "server");

  let sourceBinary = null;
  if (fs.existsSync(releaseBinary)) {
    sourceBinary = releaseBinary;
  } else if (fs.existsSync(debugBinary)) {
    sourceBinary = debugBinary;
    console.log("âš ï¸  Using debug build of server (run 'cargo build --release' for production)");
  }

  if (sourceBinary) {
    if (!fs.existsSync(serverOutDir)) {
      fs.mkdirSync(serverOutDir, { recursive: true });
    }
    const binaryDest = path.join(serverOutDir, binaryName);
    fs.copyFileSync(sourceBinary, binaryDest);
    if (platform !== "win32") {
      fs.chmodSync(binaryDest, 0o755);
    }
    console.log(`ðŸ“¦ Server binary copied: ${binaryDest}`);
  }
}

// =============================================================================
// MUPDF WORKER BUNDLING
// =============================================================================

// Copy custom MuPDF WASM build (with SIMD + LTO optimizations)
// Our custom build is 12% smaller and uses SIMD for 1.3-2.5x faster rendering
const customMupdfWasm = "src/wasm/mupdf/mupdf-wasm-simd.wasm";
const npmMupdfWasm = "../../node_modules/.pnpm/mupdf@1.27.0/node_modules/mupdf/dist/mupdf-wasm.wasm";
const mupdfWasmDest = path.join(pluginDir, "mupdf-wasm.wasm");

// Prefer custom SIMD build, fallback to npm package
if (fs.existsSync(customMupdfWasm)) {
  fs.copyFileSync(customMupdfWasm, mupdfWasmDest);
  const stats = fs.statSync(customMupdfWasm);
  const sizeMB = (stats.size / (1024 * 1024)).toFixed(1);
  console.log(`âœ… Copied custom MuPDF WASM (SIMD+LTO): ${customMupdfWasm} -> ${mupdfWasmDest} (${sizeMB}MB)`);
} else if (fs.existsSync(npmMupdfWasm)) {
  fs.copyFileSync(npmMupdfWasm, mupdfWasmDest);
  console.log(`âš ï¸  Using npm MuPDF WASM (no SIMD): ${npmMupdfWasm} -> ${mupdfWasmDest}`);
} else {
  console.warn("âŒ No MuPDF WASM file found! PDF rendering will be disabled.");
}

// Build MuPDF worker as separate bundle
console.log("ðŸ“¦ Building MuPDF worker...");
try {
  await esbuild.build({
    entryPoints: ["src/reader/renderer/pdf/mupdf-worker.ts"],
    bundle: true,
    format: "esm", // ESM required for mupdf top-level await
    target: "esnext",
    outfile: path.join(pluginDir, "mupdf-worker.js"),
    minify: prod,
    sourcemap: false,
    // Platform is browser for worker
    platform: "browser",
    // Use browser conditions for package resolution
    conditions: ["browser", "worker"],
    // Mark Node.js modules as external - they will error at runtime but that's OK
    // because mupdf conditionally imports them only in Node.js environment
    external: ["node:fs", "node:path", "fs", "path", "module"],
    // Use custom MuPDF JavaScript build instead of npm package
    // Our custom WASM has SIMD+LTO and requires matching JavaScript glue code
    alias: fs.existsSync("src/wasm/mupdf/mupdf.js") ? {
      "mupdf": "./src/wasm/mupdf/mupdf.js",
    } : {},
    // Define to help mupdf detect browser environment
    define: {
      "process.env.NODE_ENV": prod ? '"production"' : '"development"',
    },
    // Banner to set up browser-like environment in worker
    // When loaded via the wrapper, these globals are already set up
    // This banner handles the case when the ESM module is loaded directly (for testing)
    banner: {
      js: `
// Check if we're running via the wrapper (globals already set up)
// If so, skip the WASM setup - the wrapper handles it
const _wrapperMode = typeof globalThis.__MUPDF_WASM_READY__ !== 'undefined';

if (_wrapperMode) {
  console.log('[MuPDF Worker] Running in wrapper mode - WASM already configured');
} else {
  console.log('[MuPDF Worker] Running in direct mode - setting up WASM config');

  // Set up browser-like environment
  if (typeof window === 'undefined') {
    globalThis.window = self;
  }
  if (typeof process === 'undefined') {
    globalThis.process = { env: {}, versions: {} };
  } else if (process.versions) {
    // In Electron, delete process.versions.node to prevent Node.js detection
    try { delete process.versions.node; } catch (e) {}
  }

  // Configure mupdf WASM loading
  let _wasmModule = null;
  let _wasmBinary = null;
  globalThis.$libmupdf_wasm_Module = {
    wasmBinary: null,
    locateFile: function(filename) {
      console.error('[MuPDF Worker] locateFile called unexpectedly:', filename);
      return filename;
    },
    instantiateWasm: function(imports, callback) {
      if (_wasmModule) {
        console.log('[MuPDF Worker] Using pre-compiled WASM module');
        WebAssembly.instantiate(_wasmModule, imports).then(function(instance) {
          callback(instance);
        }).catch(function(err) {
          console.error('[MuPDF Worker] WASM instantiation failed:', err);
        });
        return {};
      }
      if (_wasmBinary) {
        console.log('[MuPDF Worker] Compiling WASM from binary');
        WebAssembly.instantiate(_wasmBinary, imports).then(function(result) {
          callback(result.instance);
        }).catch(function(err) {
          console.error('[MuPDF Worker] WASM compilation failed:', err);
        });
        return {};
      }
      console.error('[MuPDF Worker] No WASM module or binary!');
      return undefined;
    }
  };

  // Wait for WASM from main thread
  let wasmBinaryResolve = null;
  globalThis.__MUPDF_WASM_READY__ = new Promise(resolve => { wasmBinaryResolve = resolve; });
  self.addEventListener('message', function initHandler(event) {
    if (event.data && event.data.type === 'INIT_WASM') {
      console.log('[MuPDF Worker] Received INIT_WASM');
      if (event.data.wasmModule) {
        _wasmModule = event.data.wasmModule;
      }
      if (event.data.wasmBinary) {
        _wasmBinary = event.data.wasmBinary;
        globalThis.$libmupdf_wasm_Module.wasmBinary = event.data.wasmBinary;
      }
      wasmBinaryResolve();
      self.removeEventListener('message', initHandler);
    }
  }, { once: false });
}
`,
    },
  });
  console.log("âœ… MuPDF worker built");
} catch (error) {
  console.warn("âš ï¸  MuPDF worker build failed:", error.message);
  console.warn("   WASM PDF rendering will fall back to server-side rendering.");
}

// Build Document worker as separate bundle (unified PDF/EPUB provider)
console.log("ðŸ“¦ Building Document worker...");
try {
  await esbuild.build({
    entryPoints: ["src/reader/renderer/document-worker.ts"],
    bundle: true,
    format: "esm",
    target: "esnext",
    outfile: path.join(pluginDir, "document-worker.js"),
    minify: prod,
    sourcemap: false,
    platform: "browser",
    conditions: ["browser", "worker"],
    external: ["node:fs", "node:path", "fs", "path", "module"],
    // Use custom MuPDF JavaScript build instead of npm package
    // Our custom WASM has SIMD+LTO and requires matching JavaScript glue code
    alias: fs.existsSync("src/wasm/mupdf/mupdf.js") ? {
      "mupdf": "./src/wasm/mupdf/mupdf.js",
    } : {},
    define: {
      "process.env.NODE_ENV": prod ? '"production"' : '"development"',
    },
    banner: {
      js: `
// Shim browser environment for document worker
if (typeof window === 'undefined') {
  globalThis.window = self;
}
globalThis.process = { env: {}, versions: {} };

// Configure MuPDF WASM loading - supports both raw binary and pre-compiled module
let _wasmModule = null;
let _wasmBinary = null;
globalThis.$libmupdf_wasm_Module = {
  wasmBinary: null,
  locateFile: function(filename) {
    // This should never be called if we properly handle instantiateWasm
    console.error('[Document Worker] locateFile called unexpectedly for:', filename);
    return filename;
  },
  // Handle WASM instantiation - use pre-compiled module or compile from binary
  instantiateWasm: function(imports, callback) {
    if (_wasmModule) {
      // Use pre-compiled module - skips 400-800ms compilation per worker
      console.log('[Document Worker] Using pre-compiled WASM module');
      WebAssembly.instantiate(_wasmModule, imports).then(function(instance) {
        callback(instance);  // Emscripten expects just the instance
      }).catch(function(err) {
        console.error('[Document Worker] WASM instantiation from module failed:', err);
      });
      return {}; // Indicates async completion
    }
    // Use wasmBinary to compile and instantiate
    if (_wasmBinary) {
      console.log('[Document Worker] Compiling WASM from binary (' + _wasmBinary.byteLength + ' bytes)');
      WebAssembly.instantiate(_wasmBinary, imports).then(function(result) {
        console.log('[Document Worker] WASM compiled and instantiated from binary');
        callback(result.instance);  // Emscripten expects just the instance
      }).catch(function(err) {
        console.error('[Document Worker] WASM instantiation from binary failed:', err);
      });
      return {}; // Indicates async completion
    }
    // No module or binary - this shouldn't happen
    console.error('[Document Worker] No WASM module or binary available!');
    return undefined;
  }
};

// Wait for WASM binary/module from main thread
let wasmBinaryResolve = null;
globalThis.__MUPDF_WASM_READY__ = new Promise(resolve => { wasmBinaryResolve = resolve; });
self.addEventListener('message', function initHandler(event) {
  if (event.data && event.data.type === 'INIT_WASM') {
    console.log('[Document Worker] Received INIT_WASM message');
    // Prefer pre-compiled module if available (faster startup)
    if (event.data.wasmModule) {
      _wasmModule = event.data.wasmModule;
      console.log('[Document Worker] Received pre-compiled WASM module (skipping compilation)');
    }
    // Store wasmBinary for fallback compilation
    if (event.data.wasmBinary) {
      _wasmBinary = event.data.wasmBinary;
      globalThis.$libmupdf_wasm_Module.wasmBinary = event.data.wasmBinary;
      console.log('[Document Worker] Received WASM binary (' + event.data.wasmBinary.byteLength + ' bytes)');
    }
    if (!_wasmModule && !_wasmBinary) {
      console.error('[Document Worker] INIT_WASM received but no module or binary provided!');
    }
    wasmBinaryResolve();
    self.removeEventListener('message', initHandler);
  }
}, { once: false });
`,
    },
  });
  console.log("âœ… Document worker built");
} catch (error) {
  console.warn("âš ï¸  Document worker build failed:", error.message);
  console.warn("   Unified document provider will fall back to server-side rendering.");
}

const context = await esbuild.context({
  banner: {
    js: banner,
  },
  entryPoints: ["src/main.ts"],
  bundle: true,
  external: [
    "obsidian",
    "electron",
    "@codemirror/autocomplete",
    "@codemirror/collab",
    "@codemirror/commands",
    "@codemirror/language",
    "@codemirror/lint",
    "@codemirror/search",
    "@codemirror/state",
    "@codemirror/view",
    "@lezer/common",
    "@lezer/highlight",
    "@lezer/lr",
    ...builtins,
  ],
  format: "cjs",
  target: "es2021",
  logLevel: "info",
  sourcemap: prod ? false : "inline",
  treeShaking: true,
  outfile: "temp/vault/.obsidian/plugins/amnesia/main.js",
  define: {
    "__DEV__": prod ? "false" : "true",
  },
  plugins: [
    esbuildSvelte({
      compilerOptions: {
        css: true,
      },
      preprocess: sveltePreprocess(),
      filterWarnings: (warning) => {
        // disable a11y warnings
        return !warning.code.startsWith("a11y-");
      },
    }),
  ],
});

const cssContext = await esbuild.context({
  entryPoints: ["src/styles.css"],
  bundle: true,
  outfile: "temp/vault/.obsidian/plugins/amnesia/styles.css",
});

if (prod) {
  await context.rebuild();
  await cssContext.rebuild();
  process.exit(0);
} else {
  await Promise.all([cssContext.watch(), context.watch()]);
}
